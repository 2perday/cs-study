# 혼공컴운
## 1-1 컴퓨터 구조를 알아야 하는 이유
- 컴퓨터 구조를 이애하고 있다면 문제 상황을 빠르게 진단할 수 있고, 문제 해결의 실마리를 다양하게 찾을 수 있음.
- 이러한 역량이 업무 수행에 필요하기 때문에 각종 기업의 기술 면접에서도 이에 대한 지식을 검증하거나, 반드시 알아야 할 분야로 명시함.
- 성능, 용량, 비용
    - 프로그래밍 언어의 문법만 알아서는 해결하기 힘듦.
    - 즉, 컴퓨터 구조를 이해하여 입출력에만 집중하는 개발을 넘어 성능, 용량, 비용까지 고려해야 됨.

## 1-2 컴퓨터 구조의 큰 그림
- 컴퓨터 구조는 크게 두가지 = 컴퓨터가 이해하는 정보, 컴퓨터의 네 가지 핵심 부품.
- 0과 1로 표현되는 정보에는 데이터와 명령어가 있음. = 컴퓨터가 이해하는 정보
- 네 가지 핵심 부품
    - cpu = 중앙처리장치
    - memory = 주기억장치
    - io = 입출력장치
    - 2nd storage = 보조기억장치
- 이 때 ram, rom은 각각 random access, read only임.
- 메모리는 현재 실행되는 프로그램의 명령어와 데이터를 저장, 저장된 명령어와 데이터는 위치로써 정돈되어 있어야 하며, 따라서 값에 빠르고 효율적으로 접근하기 위해 주소 개념이 사용됨. 
- cpu
    - alu, register, control unit
- system bus = 컴퓨터의 네 가지 핵심 부품을 연결
    - 주소, 데이터, 제어 버스로 구성됨

## 2-1 0과 1로 숫자를 표현하는 방법
- 0, 1을 나타내는 가장 작은 단위 = 비트
- 비트, 바이트 = 8비트, 킬로 = 1000바이트, 메가, 기가, 테라, 페타, 엑사
- 워드 = cpu가 한 번에 처리할 수 있는 데이터 크기, 하프 워드, 풀워드, 더블워드
- 이진수의 음수 표현 = 2의 보수를 구해 이 값을 음수로 간주
- 16진수 = 0~9, A~F

## 2-2 0과 1로 숫자를 표현하는 방법
- 문자 집합 = 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩 = 문자를 0과 1로 변환하는 과정
- 문자 디코딩 = 거꾸로
- 완성형 인코딩 = 초, 중, 종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여하는 인코딩 방식
- 조합형 인코딩 = 완성형과는 다르게 각각 비트열을 할당하여 그것들의 조합으로 하나의 글자 코드를 완성하는 방식
- EUC-KR
- 유니코드
- UTF-8

## 3-1 소스 코드와 명령어
- 고급 언어 = 사람을 위함
- 저급 언어 = 기계를 위함
- 컴파일 언어, 인터프리터 언어

## 3-2 명령어의 구조
- 연산 코드 = 명령어가 수행할 연산
- 오퍼랜드 = 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치
- 따라서, 연산 코드는 연산자, 오퍼랜드는 피연산자라고도 부름.
- 연산 코드의 유형
    1. 데이터 전송
    2. 산술, 논리 연산
    3. 제어 흐름 변경
    4. 입출력 제어
- 주소 지정 방식
    - 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
    - 유효 주소 = 연산의 대상이 되는 데이터가 저장된 위치
    - 즉시 주소 지정 방식 = 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
    - 직접 = 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
    - 간접 = 유효 주소의 주소를 오퍼랜드 필드에 명시
    - 레지스터 주소 지정 방식 = 직접 주소 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
    - 레지스터 간접 주소 지정 방식 = 연산에 사용할 데이터를 메모리에 저장, 그 주소를 저장한 레지스터를 오러팬드 필드에 명시

## 4-1 ALU와 제어장치
- ALU = 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들임
    - 계산 결과와 더불어 플래그를 내보냄
    - 그리고 플래그들은 플래그 레지스터에 저장됨
- 제어장치 = 제어 신호를 내보내고, 명령어를 해석하는 부품
    1. 클럭 신호를 받아들임
    2. 해석해야 할 명령어를 받아들임
    3. 플래그 레지스터 속 플래그 값을 받아들임
    4. 시스템 버스, 제어 버스로 전달된 제어 신호를 받아들임

## 4-2 레지스터
- 종류
    1. 프로그램 카운터
    2. 명령어 레지스터
    3. 메모리 주소 레지스터
    4. 메모리 버퍼 레지스터
    5. 플래그 레지스터
    6. 범용 레지스터
    7. 스택 포인터
    8. 베이스 레지스터
- 주소 지정 방식
    1. 스택 주소 지정 방식
    2. 변위 주소 지정 방식
    3. 상대 주소 지정 방식
    4. 베이스 레지스터 주소 지정 방식

## 4-3 명령어 사이클과 인터럽트
- 명령어 사이클
- 인터럽트 = 사이클이 끊어지는 상황
- 간접 사이클 = 명령어를 실행하기 위해 메모리 접근을 한번 더 해야 하는 단계
- 동기 인터럽트 = cpu에 의해 발생하는 인터럽트
- 비동기 인터럽트 = 주로 입출력에 의해 발생
- 하드웨어 인터럽트 = 알림과 같은 인터럽트
    1. 입출력이 cpu에 인터럽트 요청 신호를 보냄
    2. cpu는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함
    3. cpu는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
    4. 인터럽트를 받아들일 수 있다면 지금까지의 작업을 백업함.
    5. 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행함
    6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업한 작업을 복구, 실행 재개함.
- 예외
    - 폴트 = 예외처리 직후 예외가 발생한 명령어부터 실행 재개
    - 트랩 = 예외처리 직후 예외가 발생한 명령어의 다음 명령어부터 실행 재개
    - 중단 = 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생
    - 소프트웨어 인터럽트 = 시스템 호출

## 5-1 빠른 CPU를 위한 설계 기법
- 클럭
- 코어
- 스레드 = 실행 흐름의 단위, 하드웨어적, 소프트웨어적으로 나뉨
    - 하드웨어적 = 하나의 코어가 동시에 처리하는 명령어 단위
    - 소프트웨어적 = 하나의 프로그램에서 독립적으로 실행되는 단위

## 5-2 명령어 병렬 처리 기법
- CPU를 쉬지 않고 작동시키는 방법
- 종류
    1. 명령어 파이프라이닝 = 동시에 여러 개의 명령어를 겹쳐 실행
    2. 슈퍼스칼라 = 여러 개의 명령어 파이프라인을 두는 방법
    3. 비순차적 명령어 처리 = 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법

## CISC, RISC
- ISA = CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속
- CISC = 복잡하고 다양한 종류의 가변 길이 명령어 집합을 활용
- RISC = 단순하고 적은 종류의 고정 길이 명령어 집합을 활용
